import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from miv.core.operator import Operator
from miv.signal.spike import ThresholdCutoff
from miv.io.openephys import DataManager
from miv.statistics.burst import burst
from miv.statistics.spiketrain_statistics import interspike_intervals



# Using Record Node 103 Experiment 1 here
data = DataManager("D:\Globus")[0]

# Spike detection operator with a cutoff threshold of 5.0 and a dead time of 3 ms
spike_detection: Operator = ThresholdCutoff(cutoff=5.0, dead_time=0.003)

# Apply spike detection to the data
data >> spike_detection

# Retrieve the spike timestamps
spikestamps = spike_detection.output

# Number of channels in the spike data
CHAMOUNT = spikestamps.number_of_channels

duration = spikestamps.get_last_spikestamp() - spikestamps.get_first_spikestamp()

# Initializing matricies
C_XY = [[[0 for _ in range(30)] for _ in range(CHAMOUNT)] for _ in range(CHAMOUNT)]
CI_XY = [[0 for _ in range(CHAMOUNT)] for _ in range(CHAMOUNT)]

# Obtain the spike times from the spike timestamps
spiketimesMega = spikestamps.neo()

#CXY Matrix implementation
for X in range(CHAMOUNT) :
    print("Doing: " + str(X))
    start_times, burst_durations, burst_lens, burst_rates = burst(spikestamps, X, 0.1, 10)
    Ys_binned = np.array([[0 for _ in range(CHAMOUNT)] for _ in range(30)])
    spikeQ = np.sum(burst_lens)
    if(spikeQ == 0) :  continue

    for time in spiketimesMega[X].magnitude :
        if any(start_time <= time <= start_time + burst_duration for start_time, burst_duration in zip(start_times, burst_durations)):
            # [:30] is done because .binning has a floating point error and sometimes gives an additional bin.
            Ys_binned += spikestamps.binning(bin_size=0.01, t_start=time-0.15, t_end=time+0.15, return_count=True).data[:30]

    if(spikeQ != 0) : Ys_norm = Ys_binned/(spikeQ * 0.01)
    else : Ys_norm = Ys_binned
    # Rotate and assign the binned spike counts to the C_XY matrix
    Ys_rot = np.rot90(Ys_norm, -1)
    Ys_rot[X] = [0 for _ in range(30)]
    C_XY[X] = Ys_rot

np.save("foo", C_XY)

#CI Matrix implementation
for X in range(CHAMOUNT) :
    for Y in range(CHAMOUNT) :
        # Calculate the connectivity index for the given channel pair
        # C_XY[14] + C_XY[15] shown here is the bucket at Tau = 0, in the paper refered to as C_XY(0)
        if(np.sum(C_XY[X][Y]) == 0) : CI = 0
        else : CI = (C_XY[X][Y][14] + C_XY[X][Y][15]) / np.sum(C_XY[X][Y])
        CI_XY[X][Y] = CI

#CX Matrix implementation
C_X = np.sum(C_XY, axis=1) / (CHAMOUNT-1)

#Visualizations
for i, sublist in enumerate(CI_XY):
    x_values = [i+1] * len(sublist)
    y_values = sublist
    plt.scatter(x_values, y_values)
plt.show()

Histo = np.array(CI_XY).flatten()
Histo = Histo[Histo != 0]
plt.hist(Histo, bins=64, edgecolor='black')
plt.show()

plt.imshow(CI_XY, cmap='hot', interpolation='nearest')
plt.colorbar()
plt.show()

plt.plot(C_X)
plt.show()

plt.imshow(C_X, cmap='hot', interpolation='nearest')
plt.colorbar()
plt.show()