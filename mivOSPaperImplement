import numpy as np
import matplotlib.pyplot as plt
from miv.core.operator import Operator
from miv.signal.spike import ThresholdCutoff
from miv.io.openephys import DataManager


# Initialize the DataManager with the specified dataset
data = DataManager("datasets\OtherData")[0]

# Spike detection operator with a cutoff threshold of 4.0 and a dead time of 0.002 seconds
# Median * Number
spike_detection: Operator = ThresholdCutoff(cutoff=5.0, dead_time=0.002)

# Apply spike detection to the data
data >> spike_detection

# Retrieve the spike timestamps
spikestamps = spike_detection.output

# Number of channels in the spike data
CHAMOUNT = spikestamps.number_of_channels

# Initializing matricies
C_XY = [[[0 for _ in range(30)] for _ in range(CHAMOUNT)] for _ in range(CHAMOUNT)]
CI_XY = [[0 for _ in range(CHAMOUNT)] for _ in range(CHAMOUNT)]

# Obtain the spike times from the spike timestamps
spiketimesMega = spikestamps.neo()

#CXY Matrix implementation
for X in range(CHAMOUNT) :
    Ys_binned = [[0 for _ in range(CHAMOUNT)] for _ in range(30)]
    for time in spiketimesMega[X].magnitude :
        # [:30] is done because .binning has a floating point error and so sometimes give an additional bin.
        Ys_binned += spikestamps.binning(bin_size=0.01, t_start=time-0.15, t_end=time+0.15, return_count=True).data[:30]
    Ys_norm = Ys_binned/(len(spiketimesMega[X].magnitude) * 0.01)

    # Rotate and assign the binned spike counts to the C_XY matrix
    Ys_rot = np.rot90(Ys_norm, -1)
    Ys_rot[X] = [0 for _ in range(30)]
    C_XY[X] = Ys_rot

#CI Matrix implementation
for X in range(CHAMOUNT) :
    for Y in range(CHAMOUNT) :
        # Calculate the connectivity index for the given channel pair
        # C_XY[14] + C_XY[15] shown here is the bucket at Tau = 0, in the paper refered to as C_XY(0)
        if(np.sum(C_XY[X][Y]) == 0) : CI = 0
        else : CI = (C_XY[X][Y][14] + C_XY[X][Y][15]) / np.sum(C_XY[X][Y])
        CI_XY[X][Y] = CI

#CX Matrix implementation
C_X = np.sum(C_XY, axis=1) / (CHAMOUNT-1)

#Visualizations
for i, sublist in enumerate(CI_XY):
    x_values = [i+1] * len(sublist)
    y_values = sublist
    plt.scatter(x_values, y_values)
plt.show()

Histo = np.array(CI_XY).flatten()
Histo = Histo[Histo != 0]
plt.hist(Histo, bins=64, edgecolor='black')
plt.show()

plt.imshow(CI_XY, cmap='hot', interpolation='nearest')
plt.colorbar()
plt.show()

plt.plot(C_X)
plt.show()

plt.imshow(C_X, cmap='hot', interpolation='nearest')
plt.colorbar()
plt.show()